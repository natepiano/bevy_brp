//! Builder for Array types
//!
//! Handles both fixed-size arrays like `[Vec3; 3]` and dynamic arrays.
//! Creates mutation paths for both the entire array and individual elements.
//!
//! **Recursion**: YES - Arrays recurse into each element to generate mutation paths
//! for nested structures (e.g., `[Transform; 3]` generates paths for each Transform).
//! This is because array elements are addressable by stable indices `[0]`, `[1]`, etc.
use std::collections::HashMap;

use serde_json::{Value, json};

use super::super::mutation_knowledge::{BRP_MUTATION_KNOWLEDGE, KnowledgeKey};
use super::super::mutation_support::MutationSupport;
use super::super::path_kind::PathKind;
use super::super::recursion_context::RecursionContext;
use super::super::types::{MutationPathInternal, MutationStatus};
use super::super::{MutationPathBuilder, TypeKind};
use crate::brp_tools::brp_type_guide::constants::{
    DEFAULT_EXAMPLE_ARRAY_SIZE, MAX_EXAMPLE_ARRAY_SIZE, RecursionDepth,
};
use crate::brp_tools::brp_type_guide::example_builder::ExampleBuilder;
use crate::brp_tools::brp_type_guide::response_types::BrpTypeName;
use crate::error::Result;
use crate::json_types::SchemaField;
use crate::string_traits::JsonFieldAccess;

pub struct ArrayMutationBuilder;

impl MutationPathBuilder for ArrayMutationBuilder {
    fn build_paths(
        &self,
        ctx: &RecursionContext,
        depth: RecursionDepth,
    ) -> Result<Vec<MutationPathInternal>> {
        // Validate and extract array information
        let (element_type, element_schema) = match Self::validate_and_extract_array_info(ctx) {
            Ok(info) => info,
            Err(error_paths) => return Ok(error_paths),
        };

        let array_size = Self::extract_array_size(ctx.type_name());
        let mut paths = Vec::new();

        // First get nested paths for complex element types - we'll use these to build our examples
        let element_path_kind =
            PathKind::new_array_element(0, element_type.clone(), ctx.type_name().clone());
        let element_ctx = ctx.create_field_context(element_path_kind);
        let element_kind = TypeKind::from_schema(element_schema, &element_type);

        let element_paths = if !matches!(element_kind, TypeKind::Value) {
            element_kind.build_paths(&element_ctx, depth)?
        } else {
            vec![]
        };

        // Extract the element example from the first element path
        // This is the indexed element path like "[0]"
        // IMPORTANT: Check hardcoded knowledge first to ensure correct BRP format
        let element_example =
            if let Some(knowledge_example) = KnowledgeKey::find_example_for_type(&element_type) {
                // Use hardcoded knowledge if available (e.g., Vec3 as array not object)
                knowledge_example
            } else if let Some(first_element_path) = element_paths
                .iter()
                .find(|p| p.path == element_ctx.mutation_path)
            {
                // If we have a path for the element itself, use its example
                first_element_path.example.clone()
            } else {
                // For Value types or when no direct path exists, generate the example using trait
                // dispatch
                element_kind
                    .builder()
                    .build_schema_example(&element_ctx, depth.increment())
            };

        // Build the main array path using the element example
        let array_example = {
            let size = array_size.unwrap_or(2);
            vec![element_example.clone(); size]
        };

        paths.push(MutationPathInternal {
            path:            ctx.mutation_path.clone(),
            example:         json!(array_example),
            type_name:       ctx.type_name().clone(),
            path_kind:       ctx.path_kind.clone(),
            mutation_status: MutationStatus::Mutatable,
            error_reason:    None,
        });

        // Build the indexed element path
        // For individual array elements, check hardcoded knowledge to ensure correct format
        let indexed_path = format!("{}[0]", ctx.mutation_path);

        // Check if we need to override an existing indexed path with hardcoded knowledge
        if let Some(knowledge_example) = KnowledgeKey::find_example_for_type(&element_type) {
            // Remove any existing path for [0] that was generated by struct builder
            let filtered_paths: Vec<_> = element_paths
                .into_iter()
                .filter(|p| p.path != indexed_path)
                .collect();

            // Add our own indexed path with hardcoded knowledge
            paths.push(MutationPathInternal {
                path:            indexed_path,
                example:         knowledge_example,
                type_name:       element_type.clone(),
                path_kind:       element_ctx.path_kind.clone(),
                mutation_status: MutationStatus::Mutatable,
                error_reason:    None,
            });

            // Add the filtered nested paths
            paths.extend(filtered_paths);
        } else {
            // No hardcoded knowledge, check if element_paths already has the indexed path
            if !element_paths.iter().any(|p| p.path == indexed_path) {
                // No existing indexed path, add one
                paths.push(MutationPathInternal {
                    path:            indexed_path,
                    example:         element_example,
                    type_name:       element_type.clone(),
                    path_kind:       element_ctx.path_kind.clone(),
                    mutation_status: MutationStatus::Mutatable,
                    error_reason:    None,
                });
            }
            // Add all nested paths
            paths.extend(element_paths);
        }

        Ok(paths)
    }

    fn build_schema_example(&self, ctx: &RecursionContext, depth: RecursionDepth) -> Value {
        let Some(schema) = ctx.require_registry_schema() else {
            return json!(null);
        };

        // Extract array element type using the same logic as the static method
        let item_type = schema
            .get_field(SchemaField::Items)
            .and_then(SchemaField::extract_field_type);

        item_type.map_or(json!(null), |item_type_name| {
            // Generate example value for the item type using trait dispatch
            // First check for hardcoded knowledge
            tracing::debug!("Array element type: {}", item_type_name.as_str());
            let item_example = BRP_MUTATION_KNOWLEDGE
                .get(&KnowledgeKey::exact(&item_type_name))
                .map_or_else(
                    || {
                        tracing::debug!(
                            "No hardcoded knowledge found for {}, using schema",
                            item_type_name.as_str()
                        );
                        // Get the element type schema and use trait dispatch directly
                        ctx.get_registry_schema(&item_type_name).map_or(
                            json!(null),
                            |element_schema| {
                                let element_kind =
                                    TypeKind::from_schema(element_schema, &item_type_name);
                                // Create element context for recursive building
                                let element_path_kind = PathKind::new_array_element(
                                    0,
                                    item_type_name.clone(),
                                    ctx.type_name().clone(),
                                );
                                let element_ctx = ctx.create_field_context(element_path_kind);
                                // Use trait dispatch directly instead of ExampleBuilder
                                element_kind
                                    .builder()
                                    .build_schema_example(&element_ctx, depth.increment())
                            },
                        )
                    },
                    |k| {
                        tracing::debug!(
                            "Found hardcoded knowledge for {}",
                            item_type_name.as_str()
                        );
                        k.example().clone()
                    },
                );

            // Parse the array size from the type name (e.g., "[f32; 4]" -> 4)
            let size = ctx
                .type_name()
                .as_str()
                .rsplit_once("; ")
                .and_then(|(_, rest)| rest.strip_suffix(']'))
                .and_then(|s| s.parse::<usize>().ok())
                .map_or(DEFAULT_EXAMPLE_ARRAY_SIZE, |s| {
                    s.min(MAX_EXAMPLE_ARRAY_SIZE)
                });

            // Create array with the appropriate number of elements
            let array = vec![item_example; size];
            json!(array)
        })
    }
}

impl ArrayMutationBuilder {
    /// Validate and extract array information from context
    fn validate_and_extract_array_info(
        ctx: &RecursionContext,
    ) -> core::result::Result<(BrpTypeName, &Value), Vec<MutationPathInternal>> {
        let Some(schema) = ctx.require_registry_schema() else {
            return Err(vec![Self::build_not_mutatable_path(
                ctx,
                MutationSupport::NotInRegistry(ctx.type_name().clone()),
            )]);
        };

        let Some(element_type) = RecursionContext::extract_list_element_type(schema) else {
            return Err(vec![Self::build_not_mutatable_path(
                ctx,
                MutationSupport::NotInRegistry(ctx.type_name().clone()),
            )]);
        };

        let Some(element_schema) = ctx.get_registry_schema(&element_type) else {
            return Err(vec![Self::build_not_mutatable_path(
                ctx,
                MutationSupport::NotInRegistry(element_type),
            )]);
        };

        Ok((element_type, element_schema))
    }

    /// Extract array size from type name (e.g., "[f32; 4]" -> 4)
    fn extract_array_size(type_name: &BrpTypeName) -> Option<usize> {
        let type_str = type_name.as_str();
        // Pattern: [ElementType; Size]
        type_str.rfind("; ").and_then(|size_start| {
            type_str.rfind(']').and_then(|size_end| {
                let size_str = &type_str[size_start + 2..size_end];
                size_str.parse().ok()
            })
        })
    }

    /// Build array example using extracted logic from `TypeGuide::build_type_example`
    /// This is the static method version that calls ``TypeGuide`` for element types
    pub fn build_array_example_static(
        type_name: &BrpTypeName,
        schema: &Value,
        registry: &HashMap<BrpTypeName, Value>,
        depth: RecursionDepth,
    ) -> Value {
        // Extract array element type using the same logic as `TypeGuide`
        let item_type = schema
            .get_field(SchemaField::Items)
            .and_then(SchemaField::extract_field_type);

        item_type.map_or(json!(null), |item_type_name| {
            // Generate example value for the item type
            let item_example =
                ExampleBuilder::build_example(&item_type_name, registry, depth.increment());

            // Parse the array size from the type name (e.g., "[f32; 4]" -> 4)
            let size = type_name
                .as_str()
                .rsplit_once("; ")
                .and_then(|(_, rest)| rest.strip_suffix(']'))
                .and_then(|s| s.parse::<usize>().ok())
                .map_or(DEFAULT_EXAMPLE_ARRAY_SIZE, |s| {
                    s.min(MAX_EXAMPLE_ARRAY_SIZE)
                });

            // Create array with the appropriate number of elements
            let array = vec![item_example; size];
            json!(array)
        })
    }

    /// Build a not-mutatable path with structured error details
    fn build_not_mutatable_path(
        ctx: &RecursionContext,
        support: MutationSupport,
    ) -> MutationPathInternal {
        MutationPathInternal {
            path:            ctx.mutation_path.clone(),
            example:         json!({
                "NotMutatable": format!("{support}"),
                "agent_directive": format!("This array type cannot be mutated - {support}")
            }),
            type_name:       ctx.type_name().clone(),
            path_kind:       ctx.path_kind.clone(),
            mutation_status: MutationStatus::NotMutatable,
            error_reason:    Option::<String>::from(&support),
        }
    }
}
