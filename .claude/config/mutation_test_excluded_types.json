{
  "excluded_types": [
    {
      "type_name": "bevy_ecs::hierarchy::ChildOf",
      "reason": "Immutable type - causes panic when mutated. Bevy's immutable types are not properly reflected yet; query says it supports mutation but it doesn't."
    },
    {
      "type_name": "bevy_render::view::window::screenshot::Screenshot",
      "reason": "Ephemeral component - only exists during screenshot operations. Not suitable for mutation testing as it's immediately consumed."
    },
    {
      "type_name": "bevy_scene::components::DynamicSceneRoot",
      "reason": "Component not present in extras_plugin test app - only added when spawning dynamic scenes."
    },
    {
      "type_name": "bevy_ui::ui_node::CalculatedClip",
      "reason": "Auto-generated internal component. Only created by Bevy's UI clipping system on child nodes when parent has overflow clipping enabled. Cannot be spawned/inserted. Requires specific UI hierarchy not present in test scene."
    },
    {
      "type_name": "bevy_anti_alias::contrast_adaptive_sharpening::DenoiseCas",
      "reason": "Render-world-only component. Automatically extracted from ContrastAdaptiveSharpening via ExtractComponent trait and only exists in the render world, not the main world. BRP can only query the main world, so this component is fundamentally not accessible."
    },
    {
      "type_name": "bevy_ecs::observer::distributed_storage::ObservedBy",
      "reason": "Internal ECS component. Automatically managed by Bevy's observer system to track which observers are watching an entity. Not user-spawnable and only added when observers are registered."
    },
    {
      "type_name": "bevy_picking::hover::DirectlyHovered",
      "reason": "Immutable component (marked with #[component(immutable)]). Automatically managed by Bevy's picking system based on HoverMap. Cannot be mutated through reflection - ComponentInfo::mutable() returns false, but this information is not exposed through BRP registry.schema."
    },
    {
      "type_name": "bevy_picking::hover::Hovered",
      "reason": "Immutable component (marked with #[component(immutable)]). Automatically managed by Bevy's picking system based on HoverMap and entity hierarchy. Cannot be mutated through reflection - ComponentInfo::mutable() returns false, but this information is not exposed through BRP registry.schema."
    },
    {
      "type_name": "bevy_pbr::wireframe::Mesh3dWireframe",
      "reason": "Handle wrapper component. TupleStruct wrapper around Handle<WireframeMaterial> which lacks ReflectDeserialize type data. Not mutable through BRP - mutability is 'not_mutable' due to handle_wrapper_component restriction. No mutation paths available for testing."
    },
    {
      "type_name": "bevy_sprite_render::mesh2d::material::MeshMaterial2d<bevy_sprite_render::tilemap_chunk::tilemap_chunk_material::TilemapChunkMaterial>",
      "reason": "Handle wrapper component. TupleStruct wrapper around Handle<TilemapChunkMaterial> which lacks ReflectDeserialize type data. Not mutable through BRP - mutability is 'not_mutable' due to handle_wrapper_component restriction. No mutation paths available for testing."
    },
    {
      "type_name": "bevy_sprite_render::mesh2d::wireframe2d::Mesh2dWireframe",
      "reason": "Handle wrapper component. TupleStruct wrapper around Handle<Wireframe2dMaterial> which lacks ReflectDeserialize type data. Not mutable through BRP - mutability is 'not_mutable' due to handle_wrapper_component restriction. No mutation paths available for testing."
    },
    {
      "type_name": "bevy_sprite_render::tilemap_chunk::TilemapChunk",
      "reason": "Immutable component. Does not have #[reflect(Component)] configured to allow mutations through reflection. All mutation attempts panic with: 'Cannot call ReflectComponent::reflect_mut on component TilemapChunk. It is immutable, and cannot modified through reflection'."
    },
    {
      "type_name": "bevy_camera::components::Camera3d",
      "reason": "Spawning Camera3d causes rendering system conflicts and panics in extras_plugin test app. Creates camera order ambiguities with existing cameras and triggers wgpu validation error: 'Texture binding 3 expects dimension = D3, but given a view with dimension = D2' in mesh_view_bind_group. Camera components require complete camera setup (Camera, Transform, render targets) that cannot be properly initialized via dynamic spawn."
    },
    {
      "type_name": "bevy_core_pipeline::skybox::Skybox",
      "reason": "Root path mutation to Default value causes app crash. The component contains Handle<Image> with Strong variant (Arc<StrongHandle>) that lacks ReflectSerialize registration, making it impossible to serialize/deserialize through BRP. Additionally, Default value creates invalid texture state - skybox shader expects Cube texture dimension but Default provides D2, causing wgpu validation panic: 'Texture binding 0 expects dimension = Cube, but given a view with dimension = D2' in prepare_skybox_bind_groups system."
    },
    {
      "type_name": "bevy_text::pipeline::TextLayoutInfo",
      "reason": "Contains AssetId<Image> and AssetId<TextureAtlasLayout> fields in nested glyphs array. Mutating these fields with invalid asset handles causes app to crash on next render frame when bevy_ui_render::extract_text_sections and extract_text_shadows systems attempt to dereference the invalid handles. Panic occurs at bevy_ui_render-0.17.2/src/lib.rs:973-1056. This is the ONLY Component out of 892 registered types that contains AssetId fields. Non-asset fields (.scale_factor, .size, .glyphs[0].position) work correctly."
    },
    {
      "type_name": "bevy_ui::widget::viewport::ViewportNode",
      "reason": "Complex setup requirements not justified for mutation testing. Requires: (1) creating a render texture with specific TextureUsages, (2) spawning a camera with RenderTarget::Image pointing to that texture, (3) spawning a UI Node with ViewportNode referencing the camera entity. The setup complexity and additional dependencies (images, cameras, render targets) don't justify inclusion in the standard mutation test suite."
    },
    {
      "type_name": "bevy_animation::transition::AnimationTransitions",
      "reason": "Array element mutation paths cannot be tested. Type spawns with empty transitions array (spawn_format: {}), but type guide includes mutation paths for array elements (.transitions[0].current_weight, .transitions[0].weight_decline_per_sec). Cannot mutate array element [0] when array is empty - results in error: 'The list accessed doesn't have index `0`'. Would need non-empty spawn format or filtered mutation paths to be testable."
    },
    {
      "type_name": "bevy_picking::pointer::PointerInteraction",
      "reason": "Immutable array field - mutations silently fail. The .sorted_entities field cannot be populated through BRP mutations (both root path and field path mutations report success but leave the array empty). Attempting to mutate array element paths like .sorted_entities[0] fails with 'The list accessed doesn't have index `0`'. The component is auto-managed by Bevy's picking system and the field appears to be read-only despite being marked as mutable in reflection."
    },
    {
      "type_name": "bevy_camera::visibility::ViewVisibility",
      "reason": "Required component - cannot be directly spawned. Automatically added when `Visibility` component is added via #[require(InheritedVisibility, ViewVisibility)] attribute. System-managed and reset to false every frame by reset_view_visibility, then computed by check_visibility based on frustum culling. Designed as read-only output for rendering systems, not user-spawnable component. Spawn attempts report success but component is not found in queries (0 entities returned)."
    },
    {
      "type_name": "bevy_camera::camera::Camera",
      "reason": "Contains PartiallyMutable enum variant with non-deserializable field. The .viewport field is Option<Viewport> where Some(Viewport) contains depth: Range<f32>. Bevy registered Range<f32> for reflection but not ReflectDeserialize, causing deserialization error: 'type core::ops::Range<f32> did not register the ReflectDeserialize type data'. This makes Option<Viewport>::Some a PartiallyMutable variant that cannot be set via mutations, rendering child mutation paths like .viewport.0.physical_position unreachable. Path builder generates these paths but they fail with 'Expected variant index access to access a Tuple variant, found a Unit variant instead' because root_example uses None variant."
    },
    {
      "type_name": "bevy_ui::ui_node::Node",
      "reason": "Excessively large component with many fields. Not representative of typical component mutation testing needs. The large number of mutation operations creates disproportionate test time without providing proportional value for validating BRP mutation functionality."
    },
    {
      "type_name": "bevy_window::window::Window",
      "reason": "Excessively large component with many fields. Not representative of typical component mutation testing needs. The large number of mutation operations creates disproportionate test time without providing proportional value for validating BRP mutation functionality. If other mutations work, this will work too."
    }
  ]
}
